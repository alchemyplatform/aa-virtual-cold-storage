// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";
import {IEntryPoint} from "account-abstraction/interfaces/IEntryPoint.sol";
import {Script, console2} from "forge-std/Script.sol";
import {ColdStoragePlugin} from "../src/ColdStoragePlugin.sol";
import {DevPaymaster} from "../src/DevPaymaster.sol";
import {FreelyMintableNft} from "../src/nft/FreelyMintableNft.sol";

contract DeployColdStorage is Script {
    IEntryPoint private constant ENTRY_POINT = IEntryPoint(0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789);

    function _deployColdStorageContracts(
        uint256 privateKey,
        string memory outFilename,
        string memory variablePrefix,
        bool deployDevPaymaster
    ) internal {
        vm.startBroadcast(privateKey);
        address plugin = _deployColdStoragePlugin();
        address freeNft = _deployFreelyMintableNft();
        address devPaymaster;
        if (deployDevPaymaster) {
            devPaymaster = _deployDevPaymaster();
        }
        string memory path = string.concat("./out/", outFilename);
        if (vm.exists(path)) {
            vm.removeFile(path);
        }
        vm.writeLine(path, "// Generated by forge deploy script");
        vm.writeLine(
            path,
            string.concat(
                "export const ", variablePrefix, '_COLD_STORAGE_PLUGIN_ADDRESS = "', vm.toString(plugin), '";'
            )
        );
        vm.writeLine(
            path, string.concat("export const ", variablePrefix, '_NFT_ADDRESS = "', vm.toString(plugin), '";')
        );
        if (deployDevPaymaster) {
            vm.writeLine(
                path,
                string.concat(
                    "export const ", variablePrefix, '_PAYMASTER_ADDRESS = "', vm.toString(devPaymaster), '";'
                )
            );
        }
        console2.log("ColdStoragePlugin: %s", plugin);
        console2.log("FreelyMintableNft: %s", freeNft);
        if (deployDevPaymaster) {
            console2.log("DevPaymaster: %s", devPaymaster);
        }
        vm.stopBroadcast();
    }

    function _deployColdStoragePlugin() private returns (address) {
        address addr = Create2.computeAddress(
            bytes32(0), keccak256(abi.encodePacked(type(ColdStoragePlugin).creationCode, abi.encode())), CREATE2_FACTORY
        );
        if (addr.code.length > 0) {
            return addr;
        }
        address plugin = address(new ColdStoragePlugin{salt: 0}());
        require(plugin == addr, "Plugin address did not match predicted");
        return plugin;
    }

    function _deployFreelyMintableNft() private returns (address) {
        address addr = Create2.computeAddress(
            bytes32(0), keccak256(abi.encodePacked(type(FreelyMintableNft).creationCode, abi.encode())), CREATE2_FACTORY
        );
        if (addr.code.length > 0) {
            return addr;
        }
        address nft = address(new FreelyMintableNft{salt: 0}());
        require(nft == addr, "NFT address did not match predicted");
        return nft;
    }

    function _deployDevPaymaster() private returns (address) {
        address addr = Create2.computeAddress(
            bytes32(0), keccak256(abi.encodePacked(type(DevPaymaster).creationCode, abi.encode())), CREATE2_FACTORY
        );
        if (addr.code.length > 0) {
            return addr;
        }
        address paymaster = address(new DevPaymaster{salt: 0}());
        require(paymaster == addr, "DevPaymaster address did not match predicted");
        ENTRY_POINT.depositTo{value: 1 ether}(addr);
        return paymaster;
    }
}
