// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";
import {IEntryPoint} from "account-abstraction/interfaces/IEntryPoint.sol";
import {Script, console2} from "forge-std/Script.sol";
import {ColdStoragePlugin} from "../src/ColdStoragePlugin.sol";
import {DevPaymaster} from "../src/DevPaymaster.sol";
import {FreelyMintableNft} from "../src/nft/FreelyMintableNft.sol";

contract DeployColdStorage is Script {
    IEntryPoint private constant ENTRY_POINT = IEntryPoint(0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789);

    function _deployColdStorageContracts(
        uint256 privateKey,
        string memory outFilename,
        string memory variablePrefix,
        bool deployDevPaymaster
    ) internal {
        vm.startBroadcast(privateKey);
        address plugin = _deployColdStoragePlugin();
        address freeNft1 = _deployFreelyMintableNft("Free NFT (dark)", "FREEd", "#182026");
        address freeNft2 = _deployFreelyMintableNft("Free NFT (light)", "FREEl", "#FDF6E3");
        address devPaymaster;
        if (deployDevPaymaster) {
            devPaymaster = _deployDevPaymaster();
        }
        string memory path = string.concat("./out/", outFilename);
        if (vm.exists(path)) {
            vm.removeFile(path);
        }
        vm.writeLine(path, "// Generated by forge deploy script");
        vm.writeLine(
            path,
            string.concat(
                "export const ", variablePrefix, '_COLD_STORAGE_PLUGIN_ADDRESS = "', vm.toString(plugin), '";'
            )
        );
        vm.writeLine(
            path, string.concat("export const ", variablePrefix, '_NFT1_ADDRESS = "', vm.toString(freeNft1), '";')
        );
        vm.writeLine(
            path, string.concat("export const ", variablePrefix, '_NFT2_ADDRESS = "', vm.toString(freeNft2), '";')
        );
        if (deployDevPaymaster) {
            vm.writeLine(
                path,
                string.concat(
                    "export const ", variablePrefix, '_PAYMASTER_ADDRESS = "', vm.toString(devPaymaster), '";'
                )
            );
        }
        console2.log("ColdStoragePlugin: %s", plugin);
        console2.log("FreelyMintableNftDark: %s", freeNft1);
        console2.log("FreelyMintableNftLight: %s", freeNft2);
        if (deployDevPaymaster) {
            console2.log("DevPaymaster: %s", devPaymaster);
        }
        vm.stopBroadcast();
    }

    function _deployColdStoragePlugin() private returns (address) {
        address addr = Create2.computeAddress(
            bytes32(0),
            keccak256(abi.encodePacked(type(ColdStoragePlugin).creationCode, abi.encode())),
            CREATE2_FACTORY
        );
        if (addr.code.length > 0) {
            return addr;
        }
        address plugin = address(new ColdStoragePlugin{salt: 0}());
        require(plugin == addr, "Plugin address did not match predicted");
        return plugin;
    }

    function _deployFreelyMintableNft(string memory name, string memory symbol, string memory backgroundColor)
        private
        returns (address)
    {
        address addr = Create2.computeAddress(
            bytes32(0),
            keccak256(
                abi.encodePacked(type(FreelyMintableNft).creationCode, abi.encode(name, symbol, backgroundColor))
            ),
            CREATE2_FACTORY
        );
        if (addr.code.length > 0) {
            return addr;
        }
        address nft = address(new FreelyMintableNft{salt: 0}(name, symbol, backgroundColor));
        require(nft == addr, "NFT address did not match predicted");
        return nft;
    }

    function _deployDevPaymaster() private returns (address) {
        address addr = Create2.computeAddress(
            bytes32(0), keccak256(abi.encodePacked(type(DevPaymaster).creationCode, abi.encode())), CREATE2_FACTORY
        );
        if (addr.code.length > 0) {
            return addr;
        }
        address paymaster = address(new DevPaymaster{salt: 0}());
        require(paymaster == addr, "DevPaymaster address did not match predicted");
        ENTRY_POINT.depositTo{value: 1 ether}(addr);
        return paymaster;
    }
}
